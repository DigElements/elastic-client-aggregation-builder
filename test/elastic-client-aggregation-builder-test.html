<!doctype html>

<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

        <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
        <script src="../../web-component-tester/browser.js"></script>

        <!-- Import the element to test -->
        <link rel="import" href="../elastic-client-aggregation-builder.html">
    </head>

    <body>
        <!-- Use the document as a place to set up your fixtures. -->
        <test-fixture id="elastic-client-aggregation-builder-fixture">
            <template>
                <elastic-client-aggregation-builder>
                </elastic-client-aggregation-builder>
            </template>
        </test-fixture>

        <script>
            suite('<elastic-client-aggregation-builder> terms', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.type = 'terms';
                    component.name = 'termsAgg';
                    component.field = 'testField';
                });

                test('name is set properly', function() {
                    expect(component.name).to.exist;
                    expect(component.name).to.equal('termsAgg');
                });

                test('field is set properly', function() {
                    expect(component.field).to.exist;
                    expect(component.field).to.equal("testField");
                });

                test('count defaults properly', function() {
                    expect(component.count).to.exist;
                    expect(component.count).to.equal(10);
                });

                test('terms aggregation clause is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.TermsAggregation('termsAgg').field('testField').size(10).toJSON());
                });
            });

            suite('<elastic-client-aggregation-builder> terms with count', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.count = 25;
                    component.type = 'terms';
                    component.name = 'termsAgg';
                    component.field = 'testField';
                });

                test('count is set properly', function() {
                    expect(component.count).to.exist;
                    expect(component.count).to.equal(25);
                });

                test('terms aggregation clause is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.TermsAggregation('termsAgg').field('testField').size(25).toJSON());
                });

                test('terms aggregation count updates on change', function(done) {
                    component.count = 20;
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON())
                    .to
                    .deep
                    .equal(ejs.TermsAggregation('termsAgg').field('testField').size(20).toJSON());
                    done();
                });

            });

            suite('<elastic-client-aggregation-builder> min', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.type = 'min';
                    component.name = 'minAgg';
                    component.field = 'testField';
                });

                test('min aggregation clause is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.MinAggregation('minAgg').field('testField').toJSON());
                });
            });

            suite('<elastic-client-aggregation-builder> max', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.type = 'max';
                    component.name = 'maxAgg';
                    component.field = 'testField';
                });

                test('max aggregation clause is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.MaxAggregation('maxAgg').field('testField').toJSON());
                });
            });

            suite('<elastic-client-aggregation-builder> date histogram', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.type = 'date_histogram';
                    component.name = 'dateAgg';
                    component.field = 'testField';
                    component.interval = 'day';
                });

                test('interval is set properly', function() {
                    expect(component.interval).to.exist;
                    expect(component.interval).to.equal('day');
                });

                test('date histogram aggregation clause is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.DateHistogramAggregation('dateAgg').field('testField').interval('day').toJSON());
                });
            });

            suite('<elastic-client-aggregation-builder> terms with order/direction', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.order = '_term';
                    component.direction = 'desc';
                    component.type = 'terms';
                    component.name = 'testAgg';
                    component.field = 'testField';
                });

                test('terms aggregation clause with order is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.TermsAggregation('testAgg').field('testField').size(10).order('_term', 'desc').toJSON());
                });

                test('terms aggregation order updates on change', function() {
                    component.order = '';
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.TermsAggregation('testAgg').field('testField').size(10).toJSON());
                });

                test('terms aggregation direction updates on change', function() {
                    component.direction = 'asc';
                    expect(component.ejsAggregation).to.exist;
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(ejs.TermsAggregation('testAgg').field('testField').size(10).order('_term', 'asc').toJSON());
                });
            });

            suite('<elastic-client-aggregation-builder> terms with nested aggregations', function() {
                var component;

                setup(function() {
                    component = fixture('elastic-client-aggregation-builder-fixture');
                    component.nestedAggregations = [ejs.TermsAggregation('nestedAgg1').field('nestedField1'), ejs.TermsAggregation('nestedAgg2').field('nestedField2')];
                    component.type = 'terms';
                    component.name = 'testAgg';
                    component.field = 'testField';
                });

                test('terms aggregation clause with nested aggregations is built properly', function() {
                    expect(component.ejsAggregation).to.exist;
                    var nested1 = ejs.TermsAggregation('nestedAgg1').field('nestedField1');
                    var nested2 = ejs.TermsAggregation('nestedAgg2').field('nestedField2');
                    var result = ejs.TermsAggregation('testAgg').field('testField').size(10).aggregation(nested1).aggregation(nested2);
                    expect(component.ejsAggregation.toJSON()).to.deep.equal(result.toJSON());
                });
            });
        </script>
    </body>
</html>
