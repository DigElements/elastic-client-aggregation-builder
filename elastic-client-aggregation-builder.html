<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../dig-common/dig-common.html">

<!--
An element which builds an elasticjs aggregation based on the set attributes.

Example:

        <elastic-client-aggregation-builder
            field: "fieldName"
            name: "aggName"
            type: "terms"
            count: "15"
            ejs-aggregation: "{{ejsAgg}}"
        >
        </elastic-client-aggregation>

@demo demo/index.html
-->

<dom-module id="elastic-client-aggregation-builder">
    <template>
    </template>

    <script>
        (function() {
            Polymer({
                is: 'elastic-client-aggregation-builder',

                properties: {
                    /**
                     * The field for which the aggregation applies
                    */
                    field: {
                        type: String
                    },

                    /**
                     * The name to be used for the aggregation in
                     * the elasticsearch  query results
                    */
                    name: {
                        type: String
                    },

                    /**
                     * The type of aggregation to build.
                     * Supported types:
                     * terms, min, max, date_histogram
                     */
                    type: {
                        type: String
                    },

                    /**
                     * The interval for date histogram aggregations.
                     */
                    interval: {
                        type: String,
                        value: 'day'
                    },

                    /**
                     * The order for aggregations.  Used with the direction property.
                     */
                    order: {
                        type: String,
                        value: ''
                    },

                    /**
                     * The direction for aggregations.  Used with the order property.
                     */
                    direction: {
                        type: String,
                        value: 'asc'
                    },

                    /**
                     * The resulting elasticjs aggregation
                    */
                    ejsAggregation: {
                        type: Object,
                        readOnly: true,
                        notify: true
                    },

                    /**
                     * the size count for aggregations which support size
                    */
                    count: {
                        type: Number,
                        value: 10,
                        observer: 'updateAggregationCount'
                    },

                    /**
                     * The array of elasticjs aggregation objects to nest within this elasticjs aggregation object (if any).
                     */
                    nestedAggregations: {
                        type: Array,
                        value: function() {
                            return [];
                        }
                    }
                },

                observers : [
                    'buildAggregation(field, name, type, nestedAggregations)'
                ],
                updateAggregationCount: function(){
                    if(this.ejsAggregation) {
                        this.buildAggregation(this.field, this.name, this.type);
                    }
                },
                buildAggregation: function(field, name, type, nestedAggregations) {
                    var ejsAggregation;
                    if(type === 'terms') {
                        ejsAggregation = ejs.TermsAggregation(name).field(field).size(this.count);
                    }
                    if(type === 'min') {
                        ejsAggregation = ejs.MinAggregation(name).field(field);
                    }
                    if(type === 'max') {
                        ejsAggregation = ejs.MaxAggregation(name).field(field);
                    }
                    if(type === 'date_histogram') {
                        ejsAggregation = ejs.DateHistogramAggregation(name).field(field).interval(this.interval);
                    }
                    if(ejsAggregation) {
                        if(this.order && this.direction) {
                          ejsAggregation.order(this.order, this.direction);
                        }
                        if(nestedAggregations) {
                            (nestedAggregations.constructor === Array ? nestedAggregations : [nestedAggregations]).forEach(function(nestedAggregation) {
                                if(nestedAggregation) {
                                    ejsAggregation.aggregation(nestedAggregation);
                                }
                            });
                        }
                        this._setEjsAggregation(ejsAggregation);
                    }
                }
            });
        })();
    </script>
</dom-module>
